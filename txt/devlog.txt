Wed Apr 28 11:36:54 AM +05 2021

Надо обдумать поведение вот этого куска кода

(define (readable P T)
  (let ((t (if (timeout? T) T 0)))
    (let poll ()
      (catch 'system-error
         (lambda () (car (select P '() '() t)))
         (lambda er (if (= EINTR (system-error-errno er))
                        (readable ports)
                        (apply throw er)))))))

readable может вернуть процедуру, которой сам и будет пользоваться для
зацикливания select-а, в случае прерываний. И тогда, нам не придётся таскать P и
T в другом коде. И это хорошо, потому что они особо не меняются.

Но тогда port-readable? Хотелось бы сделать в той же логике, Можно будет
написать:

  (define (port-readable? p t) (compose not null? (readable t p)))

Вроде, это нормально. Воплотим.

Wed Apr 28 12:10:52 PM +05 2021

Следующая мысля, которая приходит опосля. Можно превратить select в поток
событий о сработавших селекторах, потом преобразовать его в поток #:child
#:triggered.

Проблема будет только с тем, что надо отследить, когда закроется
notification-port. И эта проблема связана с тем, что придётся порты прокидывать
и в другое место ещё.

Может, ну его нафиг? И сделать просто глобальными переменными? Но тогда
потеряется компонуемость. В текущей постановке, когда notification-port
создаётся по вызову, вроде как, есть некоторая степень компонуемости. Можно
создать и отслеживать несколько таких портов в одном процессе.

Имеет смысл за это побороться. Можно тогда навешать маркеры. Мол, это
child-port, а это notification. И эти маркеры пропускать дальше. Тогда порты
будут жить в одном месте.

Хорошо, сделаем так.

Wed Apr 28 01:41:05 PM +05 2021

Плохо. Это глупо и сложно. Нужен просто поток сработавших портов. Он
инициируется из другой процедуры, которая знает о signal и notification, и может
обработать их условно. А ready-ports-stream просто выдаёт ready ports.

Sun May  2 10:43:59 AM +05 2021

Итак, у нас проблема, ЦУП. Сейчас работает контроль за дочерними процессами,
если разместить их в новой группе. Но проблема в том, что по-простому не
известно, какие процессы будут в этой группе.

Исходная проблема: пользователь посылает сигнал процессу make-watch, на который
make-watch, по идее, должен бы отреагировать остановкой своей и дочернего
процесса. Но дочерний процесс тоже породит дочерние процессы, и неплохо бы
рассылать чувствительный сигнал всем этим процессам.

Сигналы на которые хочется уметь реагировать (в минимальной версии): SIGINT и
SIGTERM.

Проблема не решается просто тем, чтобы завести глобальную переменную и писать в
неё PID дочернего процесса, лидера дочерней группы, а потом из обработчика
сигнала посылать сигнал по этому -PID.

Потому что, между моментами запуска дочернего процесса и моментом записи PID
может прийти сигнал.

Sun May  2 09:11:22 PM +05 2021

Хорошо. Проблема. Нужно уметь как-то прерывать дочерние процессы по сигналам от
пользователя.

Во-первых, прерывание всей запущенной группы работает, если эту группу оформить,
как отдельную группу.

Но проблема в том, что тогда не получится воспользоваться трюком, когда сигнал,
пойманный MW (make-watch) процессом, пересигналивается им своей же группе
(потому что мы не знаем, сколько там ещё процессов запущено, это рабочее
решение). Не работает, потому что у дочернего процесса другая группа, чтобы
реализовывать поведение выше.

Другой способ: можно передавать терминал этой запущенной группе. Но не хочется
писать вариант shell.

Проблемы здесь множественные:

  1. А если придёт сигнал, когда ещё не установлена группа у дочернего процесса?

  2. А если придёт сигнал, когда не записан pid дочерней группы в глобальную
  переменную, которую видно всем обработчикам сигнала?

Так. Вопрос требует исследования.

  1. Сигнальный интерфейс в Guile довольно бедный. Терминальный тоже не особо
     богатый. Придётся возиться с созданием pty вручную.

  2. Да, такое может быть.

Более простым решением кажется, писать всё в signal-pipe, а потом разбирать по
буквам. Если будет пойман SIGINT или SIGTERM, то, вроде как, их легко можно
будет передать дальше, а потом выполнить raise самому процессу MW.

Недостаток: потенциально возможное переполнение signal-pipe. Но, вроде, в
бытовых условиях буфера в 65k должно хватить, если отмечать сигналы символами.
Через этот же канал можно высылать уведомление о том, что дочерний процесс
теперь в своей группе.

Это улучшит прослеживание процессов.

Хорошо, пусть будет так пока. Надо переспать с этой идеей.

Mon May  3 10:29:18 AM +05 2021

Ещё одна техника, которая может быть использована для работы с процессами.
Пользователь может посылать сигналы группе, которую создаёт shell. Если дочерние
процессы не будут выходить из этой группы, то сигнал до них дойдёт.

Но в таком случае возникает проблема: а как аккуратно прервать make (это
основная программа, с которой make-watch должен работать)?

1. Можно попробовать отыскать все дочерние процессы по дереву /proc/PID. Но это
проблематично, потому что make будет запускать эти дочерние процессы, пока не
будет остановлен. Если make прибить первым, то весьма вероятно, пропадёт его
дерево /proc/PID. Можно попытаться остановить make. Но make может запускать
дочерние make-процессы, а gcc может запускать свои подпроцессы. И так далее, и
тому подобное.

Проблему можно решить, если несколько раз проходить по дереву и останавливать
процессы, пока /proc/PID дерево не будет заморожено. Но это муторный алгоритм,
который потребует выполнения большого количества системных вызовов, потенциально
вызывающих ошибки.

2. Можно поднять щит от прерываний на время группового kill. При этом,
останавливать всю группу make-watch. Кажется, это самое простое и локальное
решение, которое решит проблему интерфейса пользователя.

Если вдруг случайно пользователь попадёт на этот период исполнения кода, когда
sigint будет экранирован в основном MW-процессе, он нажмёт ещё раз ctrl+c. Это
не принципиально. Основной пользователь - я.

Mon May  3 12:28:33 PM +05 2021

Экранирование срабатывает. Только проблема в том, что в группе работает и
собиратель событий от inotify. И если прерывать MW-группу, то и он
останавливается.

Что делать?

Ну, остаётся метод signal-pipe. ArrrRgh, как говорится. Смотрим, какие буковки
(события) появляются в signal-pipe. Если #\T (SIGTERM) и #\I (SIGINT), то надо
передать этот сигнал в дочернюю группу. А потом вызвать обработчик по-умолчанию.
То есть

(sigaction SIGTERM SIG_DFL)
(raise SIGTERM)

если прилетела буква #\T.

Ещё одна важная буква #\G, которая скажет, что дочерний процесс сгруппирован, и
теперь можно посылать сигнал группе, а не отдельному процессу. Хм.

И, видимо, надо этой буквы ждать из канала.

Впрочем, нужно попробовать ещё одно решение: засовывать дочерний процесс в
группу не в самом дочернем процессе, а в процессе управляющем.

Mon May  3 02:07:41 PM +05 2021

Хорошо, это срабатывают.

Mon May  3 09:54:42 PM +05 2021

Надо прояснить ещё один вопрос: а почему не сделать наоборот? Пусть дочерний
процесс сигналит в родительский о том, что группа установлена.

Вероятно, тут всё сводится к проблеме паузы. Пауза в дочернем процессе менее
специфична. Её может прервать любой из установленных сигналов. Для аккуратности
придётся перед fork установить все сигналы в предыдущие состояния. А потом снова
зарядить их необходимыми обработчиками. Просто больше работы.

У дочернего процесса ситуация проще: нужно сбросить все сигналы в значения
по-умолчанию. Зарядить только SIGUSR1. И это проще.

Кроме того, если по каким-то причинам помрёт дочерний процесс, родительский
может застрять на паузе. Поэтому проще и более контролируемо на паузу ставить
процесс дочерний.

Кстати. Ещё есть вариант с sigstop/sigcont. Надо проверить.

Mon May  3 11:27:05 PM +05 2021

Проверено. Надёжно не работает. Хорошо. Схема с pause

Tue May  4 12:29:51 PM +05 2021

С паузой, вроде как, может работать. Но структура запуска программы довольно
тяжёлая:

  1. Сбросить обработчики сигналов в родительском процессе, чтобы обработчики не
  протекли в дочерний. Установив при этом SIGUSR1 на необходимую пустую реакцию.

  2. Сразу поставить дочерний процесс на паузу.

  3. В родительском процесс восстановить сигналы в рабочий режим.

  4. ...

Много возни. Кроме того, нет гарантий, что SIGUSR1 прилетит откуда-нибудь ещё.

А всё это нужно для чего? Чтобы синхронизировать события в дочернем и
родительском процессах. Может быть, тогда просто прокинуть pipe? Возни будет
примерно столько же, сколько с сигналами, но логика проще. И не будет мест, в
которых родительский процесс должен переключать режимы обработки сигналов.

Ok. Это не плохое решение. Хотя и более затратное по памяти. Но память быстро
освободится. Но, главное, тут, вроде как, есть определённые гарантии по порядку
событий. Более определённые, чем в случае с сигналами.

Хорошо. Пусть будет так.
