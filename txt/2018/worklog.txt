2012.04.05.09.45.18

Необходимо добавить поддержку целей. Но в какой форме? Видимо, в такой:

	build -t gcc:i686-mingw-pc:4.5.2

Это добавит два параметра tctarget = i686-mingw-pc и tcversion = 4.5.2

Проблема: нужно добавлять этих параметров в каждый toolchain. Ладно. Сделаем

Вс янв 21 13:28:26 +05 2018

Процесс переписывания вспомогательных функций на Guile Scheme. По идее, жаба
давит, поэтому буду делать через chdir, соответственно, с сохранением исходной
директории. Если сохранить не получится, то можно отказаться работать.

Вс янв 21 19:52:53 +05 2018

Проблема вот в чём. Потенциально, у нас может быть путь, который ведёт через
существующие директории. Что-нибудь типа:

  a/b/c/../c/../../b/e/f

Это, конечно, весьма иррациональная штука в контексте make. Но вполне можно себе
представить цель, которая находится в каком-нибудь каталоге

  ../../../target.

Это, в общем-то, означает, что от нас требуется некий нонсенс. Поэтому, имеет
смысл сделать логику, отличную от mkdir. Что потребует проверки пути на
корректность. Исключаем из него «..» во всех позициях, и «.» во всех позициях,
кроме первой.

Вт фев 13 15:09:12 +05 2018

Жаба давит запускать ещё один Guile с отдельной обработкой зависимостей из GCC
или Clang в ещё один процесс через pipe. Можно сделать через open-input-pipe, в
котором будет запускаться cc. Экономия на одном процессе.

Ладно. Покормить жабу.

Чт фев 15 00:30:45 +05 2018

Вопрос вот в чём. Если использовать для генерации зависимостей текущее

  $(cc) -M -MM

то теряется существенный объём информации. Надо делать -M -MG. И, видимо,
правильной стратегией будет не переименование заголовочных файлов для
автогенерируемых исходников, а аккуратное прописывание правил их копирования в
случае необходимости.

Вся надежда, конечно, на разум make. Списки объёмные. А фильтр, который в
fix-deps должен, фактически, просто менять цели в начале правила.

Сб мар 10 20:47:31 +05 2018

Работа над make-watch. Проблема с перезапуском make в случае если обнаружились
события активирующие пересборку.

Видимо, протокол может быть следующим. У нас есть переменная на три состояния:

  #:nothing-to-do - нечего делать. Об это заявляет рабочее future
  #:accounted - запрос на запуск make учтён. Об этом заявляет рабочее future
  #:need-to-remake - запрос на запуск make сформирован. Об этом заявляет основной поток.

Цикл в future:

  1. Если состояния need-to-remake, то сбрасываем его в accounted и запускаем
  make. Дальше на шаг 2.

  2. Пробуем через CAS сбросить accounted в nothing-to-do. Если получается,
  завершение. Если нет, то на шаг 3.

  3. Не получится может только по одной причине, извне записан #:need-to-remake.
  Нужен assert по этому поводу. Если так, то на шаг 1.

Цикл в основном теле, после срабатывания триггера

  1. Если текущее состояние nothing-to-do, то future уже не войдёт повторно в
  цикл, поэтому надо запускать новое future. Для этого установить режим
  need-to-remake и запустить future. Выйти.

  2. Если текущее состояние accounted, то нужно попробовать выиграть CAS-гонку с
  перебрасывание флага в need-to-remake. Если гонка проиграна, то только с
  переходом в состояния nothing-to-do. Нужен assert. Повтор цикла со
  срабатыванием шага 1.

  3. Если текущее состояния need-to-remake, то необходимость пересборки учтена,
  нечего делать.
